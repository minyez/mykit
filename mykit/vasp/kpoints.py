# -*- coding: utf-8 -*-
'''include class for KPOINTS
'''

import os
from collections.abc import Iterable

from mykit.core.kmesh import kmesh_control
from mykit.core.log import verbose


class KpointsError(Exception):
    pass

# ! kmesh_control instance is used as an attribute,
# ! since vasp does not have any tag for it
class kpoints(verbose):
    '''class for manipulation KPOINTS file.

    Note:
        Only automatic generation is supported.
        And it does not support modification of arguments

    TODO:
        Line mode

    Args:
        comment (str): the comment for KPOINTS
        kgrid (3-member list): the number of grid on each 
        kdense (integer): the density of k grid point
            If set to non-zero value and kmode is "G", "M" or "A", the kmode will automatically be set as "A".
            If kmode is set as "L" and kpath specified, it is the number of kpoints along two special points.
        kshift (3-member list): shift off center
        kmode ("G", "M", "A", "L"): the mode of KPOINTS
            "G": Gamma-centered
            "M": Monkhorse-Pack
            "A": fully automatic, i.e. the grid will be decided by kdense
            "L": line mode for bandstructure. kpath should be parse as well. Reciprocal vector unit is always used.
        kpath (nx3 array): the special points along the line. If specified, the mode will be changed to "L"
        kpoints (nx4 array): the explicit kpoints to parse. the fourth column is the kpoint weight.
            If specified, the explict mode will be triggered.
    '''

    def __init__(self, comment=None, kgrid=None, kdense=0, kshift=None, kmode="G", kpath=None, kpoints=None):
        try:
            assert kdense >= 0
        except AssertionError:
            raise KpointsError("Invalid kpoint input for kdense/grids")
        self.comment = comment
        self._relatePoscar = None
        _kmode = kmode.upper()
        try:
            assert _kmode in ["G", "M", "L", "A"]
        except AssertionError:
            raise KpointsError("Unknown KPOINTS mode: {}".format(_kmode))
        # raise when no usable parameter is input
        if not (kgrid or kdense or kpath or kpoints):
            raise KpointsError("Enter at least one of kgrid, kdense, kpath and kpoints")
        # TODO: Move the following part to script
        # Search for POSCAR to print help infomation when kdense is specified
        # if kdense != None:
        #     from mykit.vasp.poscar import poscar, PoscarError
        #     try:
        #         self._poscar = poscar.read_from_file("POSCAR")
        #         _blen = self._poscar.blen
        #         self.print_log("Reciprocal vector length %8.5f %8.5f %8.5f" % _blen, level=1)
        #     except PoscarError:
        #         pass
        
        # Consistency check
        if _kmode == "L" and (kdense == 0 or kpath == None):
            raise KpointsError("kpath should be specified and kdense > 0 for line mode")
        if _kmode == "A" and kdense == 0:
            raise KpointsError("Fully automatic mode needs positive kdense (e.g. 30)")
        if _kmode in ["G", "M"] and kgrid == None:
            raise KpointsError("kgrid should be specified for Gamma or MP mode")
        if kdense > 0 and _kmode != "L":
            _kmode = "A"
        if kpath != None:
            _kmode = "L"
        self._control = kmesh_control("mykit", kgrid=kgrid, kdense=kdense, \
            kshift=kshift, kpath=kpath, kpoints=kpoints, kmode=_kmode)

    def __print(self, fp):
        '''

        Args:
            fp (file)
        '''
        if not self.comment:
            # TODO: automatic add comment about kpath in line mode. Or determine it in script
            print("KPOINTS generated by mykit", file=fp)
        else:
            print(self.comment, file=fp)
        _explictKs = self._control.tag_vals("mykit", "kpoints")[0]
        if _explictKs != None:
            # raise NotImplementedError("Explicit mode not implemented.")
            print(len(_explictKs), file=fp)
            print("Reciprocal", file=fp)
            for _i, kp in enumerate(_explictKs):
                print("%8.5f %8.5f %8.5f %d" % kp, file=fp)
        else:
            _modeDict = {"G": "Gamma", "M": "Monkhorse-Pack", "L": "Line", "A": "Auto"}
            _kdense = self._control.tag_vals("mykit", "kdense")[0]
            _mode = self._control.tag_vals("mykit", "kmode")[0]
            if _mode == "L":
                print(int(_kdense), file=fp)
            else:
                print(0, file=fp)
            print(_modeDict[_mode], file=fp)
            if _mode in ["G", "M"]:
                _kg, _ks = self._control.tag_vals("mykit", "kgrid", "kshift")
                print(*_kg, file=fp)
                if _ks == None:
                    print(0, 0, 0, file=fp)
                else:
                    print(*_ks, file=fp)
            elif _mode == "A":
                print(int(_kdense), file=fp)
            elif _mode == "L":
                print("Reciprocal", file=fp)
                _kpath = self._control.tag_vals("mykit", "kpath")[0]
                _nSpeK = len(_kpath)
                if _nSpeK == 1:
                    raise KpointsError("At least two special points are needed to define kpath")
                for i in range(_nSpeK-1):
                    print(*_kpath[i], file=fp)
                    print(*_kpath[i+1], file=fp)
                    if i != _nSpeK - 2:
                        print('', file=fp)
            else:
                raise KpointsError("Unknown KPOINTS mode: {}".format(_mode))
        

    def print(self):
        '''Preview the KPOINTS output
        '''
        from sys import stdout
        self.__print(stdout)
        
    def write(self, pathKpoints="KPOINTS", backup=False, suffix="_bak"):
        '''Write KPOINTS to path
        '''
        _name = pathKpoints
        try: 
            assert not os.path.isdir(_name)
        except AssertionError:
            raise KpointsError("The path to write KPOINTS is a directory.")
        if os.path.isfile(_name) and backup:
            _bakname = _name + suffix.strip()
            os.rename(_name, _bakname)
        with open(_name, 'w') as f:
            self.__print(f)

    @classmethod
    def read_from_file(cls, pathKpoints="KPOINTS"):
        pass
